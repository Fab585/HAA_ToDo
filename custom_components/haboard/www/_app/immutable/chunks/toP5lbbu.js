var me=Object.defineProperty;var pe=(t,e,n)=>e in t?me(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var E=(t,e,n)=>pe(t,typeof e!="symbol"?e+"":e,n);import{a as ke,t as be}from"./B5VZwSLu.js";import{r as Te,a3 as oe,a4 as Q,J as Se}from"./DNIhbMUA.js";import{w as T,d as ae}from"./Co3IwziB.js";function tt(t){return(t==null?void 0:t.length)!==void 0?t:Array.from(t)}function nt(t,e){be(t,1,1,()=>{e.delete(t.key)})}function st(t,e,n,s,a,i,o,c,r,u,k,P){let l=t.length,m=i.length,w=l;const S={};for(;w--;)S[t[w].key]=w;const v=[],A=new Map,j=new Map,z=[];for(w=m;w--;){const d=P(a,i,w),h=n(d);let g=o.get(h);g?z.push(()=>g.p(d,e)):(g=u(h,d),g.c()),A.set(h,v[w]=g),h in S&&j.set(h,Math.abs(w-S[h]))}const H=new Set,G=new Set;function N(d){ke(d,1),d.m(c,k),o.set(d.key,d),k=d.first,m--}for(;l&&m;){const d=v[m-1],h=t[l-1],g=d.key,O=h.key;d===h?(k=d.first,l--,m--):A.has(O)?!o.has(g)||H.has(g)?N(d):G.has(O)?l--:j.get(g)>j.get(O)?(G.add(g),N(d)):(H.add(O),l--):(r(h,o),l--)}for(;l--;){const d=t[l];A.has(d.key)||r(d,o)}for(;m;)N(v[m-1]);return Te(z),v}class $ extends Error{constructor(e,n,s=!1){super(e),this.status=n,this.retryable=s,this.name="APIError"}}function X(t){return new Promise(e=>setTimeout(e,t))}class ve{constructor(e){E(this,"config");E(this,"maxRetries",3);E(this,"retryDelay",1e3);this.config=e}setAccessToken(e){this.config.accessToken=e}isRetryable(e){return!e||e>=500&&e<600||e===429||e===408}async request(e,n={},s=0){const a=`${this.config.baseUrl}${e}`,i={"Content-Type":"application/json",...n.headers};this.config.accessToken&&(i.Authorization=`Bearer ${this.config.accessToken}`);try{const o=await fetch(a,{...n,headers:i});if(!o.ok){const c=await o.json().catch(()=>({message:o.statusText})),r=new $(c.message||`HTTP ${o.status}`,o.status,this.isRetryable(o.status));if(r.retryable&&s<this.maxRetries){const u=this.retryDelay*Math.pow(2,s);return console.log(`Request failed, retrying in ${u}ms... (attempt ${s+1}/${this.maxRetries})`),await X(u),this.request(e,n,s+1)}throw r}return o.status===204?{}:o.json()}catch(o){if(o instanceof $)throw o;if(s<this.maxRetries){const c=this.retryDelay*Math.pow(2,s);return console.log(`Network error, retrying in ${c}ms... (attempt ${s+1}/${this.maxRetries})`),await X(c),this.request(e,n,s+1)}throw new $(o instanceof Error?o.message:"Network request failed",void 0,!0)}}async listTasks(e){const n=new URLSearchParams;(e==null?void 0:e.completed)!==void 0&&n.set("completed",e.completed.toString()),e!=null&&e.tag&&n.set("tag",e.tag),e!=null&&e.limit&&n.set("limit",e.limit.toString()),e!=null&&e.offset&&n.set("offset",e.offset.toString());const s=n.toString();return this.request(`/api/haboard/tasks${s?`?${s}`:""}`)}async createTask(e){return this.request("/api/haboard/tasks",{method:"POST",body:JSON.stringify(e)})}async getTask(e){return this.request(`/api/haboard/tasks/${e}`)}async updateTask(e,n){return this.request(`/api/haboard/tasks/${e}`,{method:"PUT",body:JSON.stringify(n)})}async deleteTask(e){await this.request(`/api/haboard/tasks/${e}`,{method:"DELETE"})}async completeTask(e,n=!0){return this.request(`/api/haboard/tasks/${e}/complete`,{method:"POST",body:JSON.stringify({completed:n})})}async searchTasks(e){return this.request("/api/haboard/tasks/search",{method:"POST",body:JSON.stringify(e)})}async listTags(){return this.request("/api/haboard/tags")}async createTag(e){return this.request("/api/haboard/tags",{method:"POST",body:JSON.stringify(e)})}}const p=new ve({baseUrl:typeof window<"u"?window.location.origin:""}),R=(t,e)=>e.some(n=>t instanceof n);let Y,Z;function De(){return Y||(Y=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function _e(){return Z||(Z=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const W=new WeakMap,C=new WeakMap,L=new WeakMap;function Ie(t){const e=new Promise((n,s)=>{const a=()=>{t.removeEventListener("success",i),t.removeEventListener("error",o)},i=()=>{n(b(t.result)),a()},o=()=>{s(t.error),a()};t.addEventListener("success",i),t.addEventListener("error",o)});return L.set(e,t),e}function xe(t){if(W.has(t))return;const e=new Promise((n,s)=>{const a=()=>{t.removeEventListener("complete",i),t.removeEventListener("error",o),t.removeEventListener("abort",o)},i=()=>{n(),a()},o=()=>{s(t.error||new DOMException("AbortError","AbortError")),a()};t.addEventListener("complete",i),t.addEventListener("error",o),t.addEventListener("abort",o)});W.set(t,e)}let V={get(t,e,n){if(t instanceof IDBTransaction){if(e==="done")return W.get(t);if(e==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return b(t[e])},set(t,e,n){return t[e]=n,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function ie(t){V=t(V)}function Pe(t){return _e().includes(t)?function(...e){return t.apply(F(this),e),b(this.request)}:function(...e){return b(t.apply(F(this),e))}}function Oe(t){return typeof t=="function"?Pe(t):(t instanceof IDBTransaction&&xe(t),R(t,De())?new Proxy(t,V):t)}function b(t){if(t instanceof IDBRequest)return Ie(t);if(C.has(t))return C.get(t);const e=Oe(t);return e!==t&&(C.set(t,e),L.set(e,t)),e}const F=t=>L.get(t);function Ee(t,e,{blocked:n,upgrade:s,blocking:a,terminated:i}={}){const o=indexedDB.open(t,e),c=b(o);return s&&o.addEventListener("upgradeneeded",r=>{s(b(o.result),r.oldVersion,r.newVersion,b(o.transaction),r)}),n&&o.addEventListener("blocked",r=>n(r.oldVersion,r.newVersion,r)),c.then(r=>{i&&r.addEventListener("close",()=>i()),a&&r.addEventListener("versionchange",u=>a(u.oldVersion,u.newVersion,u))}).catch(()=>{}),c}const $e=["get","getKey","getAll","getAllKeys","count"],Be=["put","add","delete","clear"],q=new Map;function ee(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(q.get(e))return q.get(e);const n=e.replace(/FromIndex$/,""),s=e!==n,a=Be.includes(n);if(!(n in(s?IDBIndex:IDBObjectStore).prototype)||!(a||$e.includes(n)))return;const i=async function(o,...c){const r=this.transaction(o,a?"readwrite":"readonly");let u=r.store;return s&&(u=u.index(c.shift())),(await Promise.all([u[n](...c),a&&r.done]))[0]};return q.set(e,i),i}ie(t=>({...t,get:(e,n,s)=>ee(e,n)||t.get(e,n,s),has:(e,n)=>!!ee(e,n)||t.has(e,n)}));const Le=["continue","continuePrimaryKey","advance"],te={},U=new WeakMap,re=new WeakMap,Me={get(t,e){if(!Le.includes(e))return t[e];let n=te[e];return n||(n=te[e]=function(...s){U.set(this,re.get(this)[e](...s))}),n}};async function*Ae(...t){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...t)),!e)return;e=e;const n=new Proxy(e,Me);for(re.set(n,e),L.set(n,F(e));e;)yield n,e=await(U.get(n)||e.continue()),U.delete(n)}function ne(t,e){return e===Symbol.asyncIterator&&R(t,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&R(t,[IDBIndex,IDBObjectStore])}ie(t=>({...t,get(e,n,s){return ne(e,n)?Ae:t.get(e,n,s)},has(e,n){return ne(e,n)||t.has(e,n)}}));const je="haboard",Ne=1;let D=null;async function ce(){return D||(D=await Ee(je,Ne,{upgrade(t){if(!t.objectStoreNames.contains("tasks")){const e=t.createObjectStore("tasks",{keyPath:"id"});e.createIndex("by-modified","modified_at"),e.createIndex("by-completed","completed")}t.objectStoreNames.contains("tags")||t.createObjectStore("tags",{keyPath:"id"}),t.objectStoreNames.contains("outbox")||t.createObjectStore("outbox",{keyPath:"id"}),t.objectStoreNames.contains("sync_state")||t.createObjectStore("sync_state",{keyPath:"key"})}}),D)}async function f(){return D||ce()}async function Ce(){return(await f()).getAll("tasks")}async function B(t){await(await f()).put("tasks",t)}async function qe(t){const n=(await f()).transaction("tasks","readwrite");await Promise.all(t.map(s=>n.store.put(s))),await n.done}async function Re(t){await(await f()).delete("tasks",t)}async function We(){return(await f()).getAll("tags")}async function ot(t){await(await f()).put("tags",t)}async function Ve(t){const n=(await f()).transaction("tags","readwrite");await Promise.all(t.map(s=>n.store.put(s))),await n.done}async function at(t){const e=await f(),s=(await e.getAll("tags")).find(a=>a.name===t);s&&await e.delete("tags",s.id)}async function _(t,e,n){const s=await f(),a=`${Date.now()}-${e}`;await s.put("outbox",{id:a,action:t,taskId:e,data:n,timestamp:Date.now(),retries:0})}async function Fe(){return(await f()).getAll("outbox")}async function Ue(t){await(await f()).delete("outbox",t)}async function Je(){const e=await(await f()).get("sync_state","last_sync");return(e==null?void 0:e.last_sync)||0}async function Ke(t){await(await f()).put("sync_state",{key:"last_sync",last_sync:t})}const de=T([]);function K(t,e,n=5e3){const s=`${Date.now()}-${Math.random()}`,a={id:s,type:t,message:e,duration:n,timestamp:Date.now()};return de.update(i=>[...i,a]),n>0&&setTimeout(()=>{ze(s)},n),s}function ze(t){de.update(e=>e.filter(n=>n.id!==t))}function M(t,e){return K("success",t,e)}function He(t,e){return K("error",t,8e3)}function I(t,e){return K("warning",t,e)}const ue=T(typeof navigator<"u"?navigator.onLine:!1),se=T(!1),le=T(0),J=T(null),y=T([]),fe=T([]),it=ae(y,t=>t.filter(e=>!e.completed).sort((e,n)=>e.priority!==n.priority?n.priority-e.priority:e.due_date&&n.due_date?e.due_date.localeCompare(n.due_date):0)),rt=ae(y,t=>t.filter(e=>e.completed).sort((e,n)=>e.completed_at&&n.completed_at?n.completed_at.localeCompare(e.completed_at):0));async function ct(t){await ce();const e=await Je();le.set(e);const[n,s]=await Promise.all([Ce(),We()]);y.set(n),fe.set(s),typeof window<"u"&&(window.addEventListener("online",ye),window.addEventListener("offline",we),navigator.onLine&&await he())}async function ye(){console.log("Device is online"),ue.set(!0),J.set(null),M("Connection restored - syncing..."),await he()}function we(){console.log("Device is offline"),ue.set(!1)}async function he(){if(!navigator.onLine){console.log("Cannot sync: offline");return}se.set(!0),J.set(null);try{await Ge();const[t,e]=await Promise.all([p.listTasks({limit:1e3}),p.listTags()]);y.set(t),fe.set(e),await Promise.all([qe(t),Ve(e)]);const n=Date.now();le.set(n),await Ke(n),console.log("Sync completed successfully")}catch(t){console.error("Sync failed:",t);const e=t instanceof $?t.message:"Sync failed";J.set(e),He(`Sync failed: ${e}`)}finally{se.set(!1)}}async function Ge(){const t=await Fe();for(const e of t)try{switch(e.action){case"create":await p.createTask(e.data);break;case"update":await p.updateTask(e.taskId,e.data);break;case"delete":await p.deleteTask(e.taskId);break}await Ue(e.id)}catch(n){console.error("Failed to process outbox item:",e,n)}}async function dt(t){const e={id:crypto.randomUUID(),title:t.title||"",notes:t.notes||null,due_date:t.due_date||null,due_time:t.due_time||null,priority:t.priority||0,completed:!1,completed_at:null,created_at:new Date().toISOString(),modified_at:new Date().toISOString(),device_id:"web_client",version:1,tags:t.tags||[]};if(y.update(n=>[...n,e]),await B(e),navigator.onLine)try{const n=await p.createTask({...e,notes:e.notes||void 0,due_date:e.due_date||void 0,due_time:e.due_time||void 0});return y.update(s=>s.map(a=>a.id===e.id?n:a)),await B(n),M("Task created successfully"),n}catch(n){console.error("Failed to create task on server:",n),await _("create",e.id,e),await x(),I("Task saved offline - will sync when connection restored")}else await _("create",e.id,e),await x(),I("Working offline - task will sync when connection restored");return e}async function Qe(t,e){const s=oe(y).find(i=>i.id===t);if(!s)return null;const a={...s,...e,modified_at:new Date().toISOString(),version:s.version+1};if(y.update(i=>i.map(o=>o.id===t?a:o)),await B(a),navigator.onLine)try{const i=await p.updateTask(t,{...e,notes:e.notes===null?void 0:e.notes,due_date:e.due_date===null?void 0:e.due_date,due_time:e.due_time===null?void 0:e.due_time});return y.update(o=>o.map(c=>c.id===t?i:c)),await B(i),M("Task updated successfully"),i}catch(i){console.error("Failed to update task on server:",i),await _("update",t,e),await x(),I("Task saved offline - will sync when connection restored")}else await _("update",t,e),await x(),I("Working offline - changes will sync when connection restored");return a}async function ut(t){if(y.update(e=>e.filter(n=>n.id!==t)),await Re(t),navigator.onLine)try{await p.deleteTask(t),M("Task deleted successfully")}catch(e){console.error("Failed to delete task on server:",e),await _("delete",t),await x(),I("Task deleted locally - will sync when connection restored")}else await _("delete",t),await x(),I("Working offline - deletion will sync when connection restored")}async function lt(t){const n=oe(y).find(i=>i.id===t);if(!n)return;const s=!n.completed,a=s?new Date().toISOString():null;await Qe(t,{completed:s,completed_at:a})}async function x(){if("serviceWorker"in navigator&&"sync"in ServiceWorkerRegistration.prototype)try{await(await navigator.serviceWorker.ready).sync.register("haboard-sync"),console.log("Background sync registered for outbox processing")}catch(t){console.warn("Background sync registration failed:",t)}}function ft(){typeof window<"u"&&(window.removeEventListener("online",ye),window.removeEventListener("offline",we))}function ge(t){const e=t-1;return e*e*e+1}function yt(t){return--t*t*t*t*t+1}function wt(t,{delay:e=0,duration:n=400,easing:s=Se}={}){const a=+getComputedStyle(t).opacity;return{delay:e,duration:n,easing:s,css:i=>`opacity: ${i*a}`}}function ht(t,{delay:e=0,duration:n=400,easing:s=ge,x:a=0,y:i=0,opacity:o=0}={}){const c=getComputedStyle(t),r=+c.opacity,u=c.transform==="none"?"":c.transform,k=r*(1-o),[P,l]=Q(a),[m,w]=Q(i);return{delay:e,duration:n,easing:s,css:(S,v)=>`
			transform: ${u} translate(${(1-S)*P}${l}, ${(1-S)*m}${w});
			opacity: ${r-k*v}`}}function gt(t,{delay:e=0,duration:n=400,easing:s=ge,start:a=0,opacity:i=0}={}){const o=getComputedStyle(t),c=+o.opacity,r=o.transform==="none"?"":o.transform,u=1-a,k=c*(1-i);return{delay:e,duration:n,easing:s,css:(P,l)=>`
			transform: ${r} scale(${1-u*l});
			opacity: ${c-k*l}
		`}}export{Qe as A,p as a,ot as b,wt as c,ze as d,tt as e,ht as f,at as g,gt as h,ct as i,dt as j,lt as k,ut as l,le as m,de as n,nt as o,y as p,yt as q,rt as r,he as s,fe as t,st as u,it as v,se as w,ue as x,J as y,ft as z};
